#1 基本原则
1，满足组合优于继承的原则，Entity只是一个空的壳子，它可以是任意东西，一个人，一棵树。取决于其持有的AI行为树、组件
2，使用分桶（bucket）策略，避免管理器频繁遍历所有Entity。
2.1，对于Entity需要由优先级（活跃度）分类，，例如石头、草之类的静态物放入桶1；怪物，玩家等活跃物体放入桶2。
2.2，同时引入LOD System (Level of Detail System)，负责调度Entity的分桶，例如
实例管理器在管理 ActiveAgent 时，根据其与玩家（摄像机）的距离，动态调整更新频率：
- 近距离（<20米）: 每帧更新行为树（全功能，甚至包括面部表情）。
- 中距离（20-50米）: 每5帧更新一次行为树（只处理移动和大概的行为）。
- 远距离（>50米）: 停止行为树更新，只保留极简的数据模拟（或者直接休眠）。
具体的你自己发挥，我需要的是同时兼容，设计上的分类和运行时的逻辑分类
3，需要组件和行为树的设计，符合迪米特法则 (Law of Demeter) / 最少知识原则，单一设计原则
4，对于管理器和entity的关系，符合好莱坞原则
5，对于entity的设计和扩充，符合开闭原则
6，对于整体设计，符合kiss原则
7，可以参考《饥荒》的设计

#2 工业化迈进
8，对于Entity和行为的创建，不要使用当前“硬编码工厂模式”（Hardcoded Factory）；
9，引入“注册表模式 (Registry Pattern)” 和 “生命周期钩子 (Lifecycle Hooks)”。以支持外部灵活修改Entity属性和拓展行为树（详见EntityNew.MD）
10，引入Luban配置表工具，创建Entity时再也不要传入一大堆参数了，将不同种类的Entity分开配表，避免合作冲突以及属性的冗余
